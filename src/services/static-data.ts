// Static data loader for pre-fetched season data
// This loads bundled JSON files instead of making API calls

import type { Race, RaceCalendar, Driver } from 'src/types';

// Static data type matching the JSON structure
interface StaticRaceResult {
  driverId: string;
  driverCode: string;
  firstName: string;
  lastName: string;
  constructorId: string;
  constructorName: string;
  position: number | null;
  points: number;
  grid: number;
  status: string;
  fastestLap: boolean;
  fastestLapRank: number | null;
}

interface StaticRace {
  season: number;
  round: number;
  raceName: string;
  circuitId: string;
  circuitName: string;
  country: string;
  date: string;
  results: StaticRaceResult[];
  qualifying: Array<{ driverId: string; position: number }>;
  sprint: Array<{ driverId: string; position: number | null; points: number }> | null;
}

interface StaticCalendarEntry {
  season: number;
  round: number;
  raceName: string;
  circuitId: string;
  circuitName: string;
  country: string;
  date: string;
}

interface StaticSeasonData {
  calendar: StaticCalendarEntry[];
  races: StaticRace[];
}

// Dynamic imports for static data files
// These are generated by scripts/fetch-season-data.mjs
async function loadStaticDataModule(year: number): Promise<StaticSeasonData | null> {
  try {
    switch (year) {
      case 2025: {
        const module = await import('../../data/2025.json');
        return module.default as StaticSeasonData;
      }
      case 2026: {
        const module = await import('../../data/2026.json');
        return module.default as StaticSeasonData;
      }
      default:
        return null;
    }
  } catch {
    return null;
  }
}

// Check if static data exists for a season
export function hasStaticData(year: number): boolean {
  return year === 2025 || year === 2026;
}

// Load static season data
export async function loadStaticSeasonData(
  year: number
): Promise<{ calendar: RaceCalendar[]; races: Race[] } | null> {
  const data = await loadStaticDataModule(year);
  if (!data || data.races.length === 0) {
    return null;
  }

  try {
    // Transform static races to match our Race type
    const races: Race[] = data.races.map((race) => ({
      season: race.season,
      round: race.round,
      raceName: race.raceName,
      circuitId: race.circuitId,
      circuitName: race.circuitName,
      country: race.country,
      date: race.date,
      results: race.results.map((r) => ({
        driverId: r.driverId,
        position: r.position,
        points: r.points,
        grid: r.grid,
        status: r.status,
        fastestLap: r.fastestLap,
        fastestLapRank: r.fastestLapRank,
        // Include driver info for extraction
        driverCode: r.driverCode,
        firstName: r.firstName,
        lastName: r.lastName,
        constructorId: r.constructorId,
        constructorName: r.constructorName,
      })),
      qualifying: race.qualifying,
      sprint: race.sprint,
    }));

    // Add hasSprintRace to calendar entries
    const calendar: RaceCalendar[] = data.calendar.map((entry) => ({
      ...entry,
      hasSprintRace: data.races.find((r) => r.round === entry.round)?.sprint !== null,
    }));

    return { calendar, races };
  } catch {
    return null;
  }
}

// Extract drivers from static race data
export function extractDriversFromStaticData(races: StaticRace[]): Driver[] {
  const driverMap = new Map<string, Driver>();

  for (const race of races) {
    for (const result of race.results) {
      if (!driverMap.has(result.driverId)) {
        driverMap.set(result.driverId, {
          driverId: result.driverId,
          code: result.driverCode,
          firstName: result.firstName,
          lastName: result.lastName,
          nationality: '',
          constructorId: result.constructorId,
          constructorName: result.constructorName,
        });
      }
    }
  }

  return Array.from(driverMap.values());
}
